# Link Layer

[TOC]

## Previous

 Application Layer -> Transport Layer(TCP / UDP) -> Network Layer(IP) 여기까지 했다. TCP 이야기 할 때는 Network는 알지 못하고 어떻게 Reliable하게 데이터를 전달했는지 설명했다. 이후 IP를 이야기 할 때 라우터를 통해 전달하고, Forwarding table보면서 이동한다고 설명했다. 각 단계를 설명할 때 다음단계는 추상화된 상태로 설명해왔다. 다음 Layer도 같음. 추상화를 한겹 더 뜯어보는 것. Gateway router를 실제로 보면 랜선이 복잡하게 연결되어 있을 것이다. 또는 와이파이 인터페이스로 연결되어 있다. 이전까지는 추상적으로 전용선이 있다고 설명했는데 실제로는 그렇지 않다. 이번 시간부터 이야기할 내용은 네트워크 호스트 간에 패킷이 어떻게 전달되는지. 여기에서 바로 앞에 있는 게이트웨이까지 어떻게 전달 되는지에 대해 알아본다. 어떻게 하면 충돌없이 게이트웨이 라우터까지 전달할 수 있을지. 등등이 링크 레이어의 핵심이다. 무선 와이파이든 유선 케이블이든 어떻게 바로 다음 홉에 전달할 수 있을지. 바로 다음 홉으로 어떻게 이동하냐에 대한 이야기.

## Multiple Access Link, Protocol

 링크 레이어는 종류가 무궁무진하다. 와이파이, 3G, LTE, LAN, 블루투스 등 연결할 수 있는 종류가 다양하다. 어떤 걸 쓰든간에 TCP/IP만 쓰면 인터넷은 되니까.

Link Layer의 전송 단위는 Frame이다. 이 프레임이 다른 장비들에서 동시에 전달되면 충돌나서 쓸 수 없게 된다. 이것을 처리하는 역할이 Link Layer.

Broadcast Medium : 게이트웨이 라우터에게만 전달했을 뿐인데 사실 다 들린다. 내가 누구한테 '시간 있어요'라고 물어보면 주변 사람들도 다 들린다. 이러한게 브로드캐스트 미디엄. 이러한 상황에서 여러 사람이 말하면 오디오 겹침. 게이트웨이 라우터 입장에서도 똑같다.

### Ideal multiple Access Protocol

 R bps의 속도를 가진 브로드캐스트 채널에서, 1) 한 사람이 전송하길 원하면, R bps의 속도만큼 전송할 수 있어야 한다. 2) M개의 노드가 전송하길 원하면, R/M bps만큼의 속도만큼 전송할 수 있어야 한다. 3) 중간에 누가 있어서 교통정리 해주는 것이 아니라, 각자 분산적으로 대화할 수 있어야 한다. 중재자 필요없이. 4) 단순한 프로토콜이어야 한다. 이 네 가지 바람이 충족되어야 한다.

### MAC(Medium Access Control) Protocol : Taxonomy

 누가 말을 할 지 컨트롤 하는 프로토콜. 어느 미디엄이 접근할 수 있는지 제어하는 것. 

#### Channel Partitioning

##### TDMA : Time Division Multiple Access

 시간을 나눠서 액세스한다. 시간을 나눠서 이 시간엔 니가 Access해. 1) 장점: 충돌나지 않는다. 2) 단점1 : 노드 개수가 적을 때, 비효율적이다.

##### FDMA : Frequency Division Multiple Access

 주파수를 나눈다. 1) 장점 : 충돌 안생김, 2) 단점 : 노드 개수가 적을 때, 채널 사용이 비효율적이다.

#### Random Access

 채널 파티셔닝 방식의 장단점을 극단적으로 바꿈. 원할 때 자기 하고 싶은 말 하는 것. 동시에 액세스 하면 충돌 생김. Collision 발생 시, 어떻게 recovery 할지. 현실적으로 랜덤 액세스 많이 사용함. 

##### CSMA(Carrier Sense Multiple Access)

내가 전송하고 싶은 프레임이 있을 때, 누군가 이야기 하고 있으면 전송하지 않고, 없으면 이야기 하겠다. 사람이 이야기하는 것과 같음. 옆에서 친구 이야기 하고 있는데 다른 이야기하면 좀 그렇잖아 ;; 

###### CSMA Collision

 전자기파가 퍼지고 있는데 나는 아직 못들음. 그런데 내가 이야기하고 싶다. 그래서 캐리어 센스 해보니까, 아무도 이야기 하지 않고 있는것으로 나옴. 그래서 이야기 했는데, 충돌났다. 전자기파의 진행속도가 빛의 속도라는 물리적 제한이 있다. 이걸 해결할 방법이 없다. 그래서 충돌 발생 시 피해를 최소화하는 방법이 CSMA/CD이다.

![csma collision에 대한 이미지 검색결과](https://www.cs.umd.edu/~shankar/417-F01/Slides/chapter5a-aus/img026.gif)

##### CSMA/CD(Collision Detection)

  둘이 이야기 하는데 말이 겹침. Collision 발생 했다는 걸 탐지하고 일단 둘 다 멈춤.  낭비되는 데이터 양은 더 적음. Detect하는 순간 내 프레임 전송을 멈춘다는 것은 이 프레임이 날라갔다는 말. 재전송 해야 한다. Random time을 돌리고 이 시간 이후에 다시 재전송 시도한다. Random time이 길면 비효율 발생할 것이다. 랜덤의 선택 폭이 좁아야 재전송할 것이다. 하지만 너무 좁으면 또 충돌날 가능성이 있다. 첫 충돌에 대해서는 짧게, 또 충돌나면 곱하기 2, 또 충돌나면 곱하기 2 ... 이렇게 된다.  Binary Expand Buffer. 이더넷이든 와이파이든 많은 호스트가 붙어있으면 우리가 체감하는 딜레이가 크다. 인터넷 속도가 왜 이렇게 느리지 하는 것은 Link Layer의 문제이다. 

 내가 전송하는 전자기파의 Signal Strenth와 다른 사람의 신호 세기는 비슷하다. 케이블로 보호되어 있기 때문에. 나는 말하면서 또 듣고 있다. 내가 말하는 정보와 듣는 정보가 다르면 충돌난 것이다.

#### Taking turns

 channel partitioning과 random access는 극단적으로 다른 장단점을 가지고 있다. channel partitioning은 사용자가 많을 때 유리, random access는 사용자가 적을 떄 유리.

##### 방안 1

 taking turns는 중앙에서 관리하는 것. 사회자. random access의 장점인 원하는 때 보낼 수 있는 것이 있지만, 중앙 관리 시스템이 다운되면 망.

##### 방안 2

 토큰이라는 특별한 데이터로 관리. 토큰이 있으면 보낼 데이터 보낼 수 있다. 토큰이 없으면 못보냄. 토큰 잃어버리면 망.

## Ethernet

 스위치라는 장치를 두고 추가할 호스트가 있으면 꽂는다. IP 패킷이 링크 레이어로 와서 헤더가 쌓이고 Frame이 된다.

![Ethernet header에 대한 이미지 검색결과](https://119904-342459-raikfcquaxqncofqfm.stackpathdns.com/wp-content/uploads/2019/01/ethernet-header.png)

- Preamble은 무시. 
- Destination Addr, Src addr. 이거는 MAC addr이다.
- type은 arp냐 뭐냐. 이런거 알려주는거고. 

CSMA/CD를 사용한다. 구글까지 데이터 보내고 싶다. 링크 레이어는 일단 나의 바로 앞에 있는 게이트웨이까지 패킷을 잘 보내는 것이 목표이다. 어떻게 살아서 게이트웨이까지 갈 수 있을까. 

 내가 프레임을 CSMA/CD를 통해 보냈다. 그런데 피드백을 주지 않으니까 갔는지 아닌지 확신이 없다. 유선상황에서는 최소한 외부로부터 노이즈가 없기 때문에 우리간의 충돌만 없으면 게이트웨이까지 간다. 충돌이 있을 경우, 나는 재전송하면 된다. 그렇다면 CSMA/CD에서 Collision Detection이 가장 중요하게 된다. 만약 충돌났는데 내가 감지하지 못한다면 재전송을 못하니까 망하는 것. 결국 CSMA/CD에서는 100% collision detection이 되어야 한다. 그러면 어느 경우에 Collision Detection을 못하게 될까??

### 상황

 A가 전송하고 싶어서 Carrier sense 했는데 가능하다고 나옴. 그래서 데이터 보낸다. 그래서 B C D E F까지 간 상태임. G가 데이터 보내고 싶어서 캐리어 센스 해봄. 자신에게 아무것도 도착하지 않았으니까 데이터 보낸다. 보내고 나니까 콜리전 생긴거 알게됨. 멈춘다. 그러면 앞에 말한 것들은 다시 담을 수 없다. 앞에 보낸 것들이 F E D C B까지 가면서 콜리전이 계속 발생하고 있다. A에게 도착하기 전에 A는 모든 데이터를 다 보냈다. 그러면 A 입장에서는 다 보냈다고 생각해서 재전송 하지 않는다. 그러나 데이터는 콜리전 생겼기 때문에 망함. G는 충돌감지 제대로 했지만, A는 하지 못했다.

 A는 왜 충돌감지 못했을까. A의 프레임이 조금만 더 컸으면 충돌방지 할 수 있지 않을까. 분명 Propagation delay가 있는데 이걸 감당할만큼 A 프레임의 사이즈가 크지 않았다. A의 프레임이 너무 짧았다. Lan선의 최대 길이, Propagation delay를 감안해서 프레임 사이즈에 최소값이 정해져있다. 64byte. 내가 보내고자 하는 실제 바이트는 15바이트이면, 뒤에 패딩을 붙인다. 이야기가 끝났지만 뒤에 Padding을 보낸다. 00000... 이런식으로.

 이제 100% detect 하기 때문에 무조건 게이트웨이 라우터로 간다고 할 수 있다. 

### MAC

|      | 사람 | 호스트 |
| ---- | ---- | -------- |
| 이름 | 박길성 | 호스트네임 |
| 주소 | 경상북도 경주시 -- | IP주소 |
| 주민번호 | 940223-1111111 | MAC 주소 |

 이름이나 주소는 바꿀 수 있지만 MAC 주소는 바꿀 수 없다. IP주소도 인터페이스를 지칭하긴 하지만, MAC주소는 기기가 이동하더라도 변하지 않고, IP주소는 다른 와이파이로 이동하면 바꿀 수 있다. IP주소는 웹 상의 어디에 위치해 있는지에 대한 로지컬 주소이다.

 IP 패킷의 헤더에 dest addr, src addr이 담기게 된다. 그리고 프레임에도 dest addr, src addr이 있는데, 프레임의 주소는 MAC 주소이다. IP 패킷만 봤을 때는 처음부터 도착할 때까지 안바뀜. 프레임에 있는 주소는 그럼 뭐지. 게이트웨이 라우터에게 보내는 정보이다. 결국 게이트웨이의 MAC주소가 dest addr에 들어가게 된다. 그런데 소스에 게이트웨이 라우터 정보가 없다 ;; 호스트는 게이트웨이 라우터의 IP주소밖에 모른다. 처음에 dhcp 서버가 나에게 IP주소 줄 때, 내 IP, 내 서브넷 주소와 게이트웨이 IP 주소, Name Server IP주소. 이러한 정보가 ARP Table에 있다.

### ARP(Address Resolution Protocol)

 게이트웨이 IP의 맥주소를 알고 싶은데 어떻게 하지. arp 쿼리를 브로드캐스트로 보낸다. 이 때는 Data부분에 arp 정보가 들어간다. 데이터 안에 내가 알고자하는 IP주소를 적고 브로드캐스트하면, 해당 IP는 응답해서 MAC 주소를 보낸다. 그러면 ARP Table에 게이트웨이 IP와 MAC주소를 저장해놓는다. TTL은 Time to live. IP주소는 변할 수 있으니까 시간을 정해서 갱신하도록 함.

 게이트웨이는 프레임을 받아서 나한테 온게 맞으면 프레임을 뜯는다. 그러면 포워딩 테이블을 통해 다시 프레임을 씌워서 보낸다. 프레임의 헤더만 계속 바뀌고 IP 패킷의 변화는 없다. 

## LAN

### Switch

 호스트 관점에서 스위치는 눈에 보이지 않는다. transparent하다. 스위치는 맥 주소도 없고, 말그대로 전달만해주는 장치이다. 스위치는 교통정리만 해준다. 호스트는 아예 스위치를 생각하지 않는다. 스위치가 있어서 LAN을 구성하긴 편함.  스위치가 존재하면 좋음.

#### Multiple Simultaneous transmission

 브로드캐스팅 미디엄이라는 개념을 분리시키는 역할을 한다. 스위치 내부적으로만 잘 포워딩해주면 충돌나지 않고 잘 보내줄 수 있다. A가 B에 데이터 보내려고 하고, 동시에 C도 B에 보내려고 한다. 그러면 스위치에 들어옴. 받아서 한 명씩 보내주면 싸우지 않고 잘 갈 수 있다. 스위치가 등장하면 충돌이 없다. 

#### Self-learning

 스위치에도 테이블이 있다. 이걸 어떻게 채우냐. A한테서 데이터 받으면 소스 맥 주소 보고 아 얘는 인터페이스 1번에 연결되어 있구나. 그런데 목적지 B도 알아야 하는데 무슨 인터페이스인지 모른다. Flooding 한다. 나머지 애들에게 다 보내는 것. 애들은 자기 것이 아니면 버릴 것이고, B는 받아서 대답할 것이다. 그러면 B가 보낸 데이터 받아서 테이블에 채운다. 이런 식으로 반복하다보면 얼마 지나지 않아 채워지게 된다. 

#### Interconnecting Switches

![interconnected switch에 대한 이미지 검색결과](https://d2vlcm61l7u1fs.cloudfront.net/media%2F33d%2F33d85d40-cbe2-4d45-8832-6d712167d6e1%2Fphp5I1l74.png)	

 스위치와 스위치를 연결하면 무제한으로 스위치를 사용할 수 있게 된다. 이렇게 연결된 스위치 구조에서 어떻게 테이블 구성하냐. 이것도 셀프 러닝으로 가능하다.

 각 스위치의 인터페이스 번호는 S1으로 알아보자. S4와 연결된 인터페이스 하나랑 호스트랑 연결된 3개 총 4개가 있다.

## Data Center and Network

 엄청나게 많은 규모의 사용자들을 처리하기 위해서는 엄청 많은 서버들이 한 곳에 모여 있어서 이것을 분산시켜준다. 서버들을 한 군데 모아놓은 것을 데이터 센터라고 한다. 구글, 네이버 등 IT 기업은 당연히 데이터 센터를 가지고 있다. 이러한 서버들을 연결하는 방법이 이더넷, 스위치와 케이블을 사용해서이다. 여러개의 스위치, 라우터로 엄청나게 규모가 큰 이더넷을 구성할 수 있다.

## 차단

 STK 게이트웨이 라우터에서 차단할 IP가 있다면 접속 못하게 한다. 들어오는 IP 패킷 잡아서 드랍시킨다. 그렇게 되면 우리는 Warning 을 못본다. warning.html을 보여줘야 하는데... 그럼 나라에서 차단하면서 html까지 띄우기 위한 방법은 무엇일까. 띄우기 위해서는 tcp connection이 있고, 그 사람이 나한테 warning.html을 보내야 한다. 그런데 어떻게 했지????? 큰 그림을 알았기 때문에 이상하단는 걸 느낌.

 그냥 SKT 게이트웨이에서 유저가 원하는 사이트 가도록 보냄. 그리고 tcp 연결이 되면 이제 라우터에서 검열시작. 유저가 데이터 보내는 걸 받아서, tcp src를 속여서 그 안에 warning.html을 넣어서 유저한테 보냄.

 https를 사용하면 방법없음.