# Link Layer

[TOC]

## Previous

 Application Layer -> Transport Layer(TCP / UDP) -> Network Layer(IP) 여기까지 했다. TCP 이야기 할 때는 Network는 알지 못하고 어떻게 Reliable하게 데이터를 전달했는지 설명했다. 이후 IP를 이야기 할 때 라우터를 통해 전달하고, Forwarding table보면서 이동한다고 설명했다. 각 단계를 설명할 때 다음단계는 추상화된 상태로 설명해왔다. 다음 Layer도 같음. 추상화를 한겹 더 뜯어보는 것. Gateway router를 실제로 보면 랜선이 복잡하게 연결되어 있을 것이다. 또는 와이파이 인터페이스로 연결되어 있다. 이전까지는 추상적으로 전용선이 있다고 설명했는데 실제로는 그렇지 않다. 이번 시간부터 이야기할 내용은 네트워크 호스트 간에 패킷이 어떻게 전달되는지. 여기에서 바로 앞에 있는 게이트웨이까지 어떻게 전달 되는지에 대해 알아본다. 어떻게 하면 충돌없이 게이트웨이 라우터까지 전달할 수 있을지. 등등이 링크 레이어의 핵심이다. 무선 와이파이든 유선 케이블이든 어떻게 바로 다음 홉에 전달할 수 있을지. 바로 다음 홉으로 어떻게 이동하냐에 대한 이야기.

## Multiple Access Link, Protocol

 링크 레이어는 종류가 무궁무진하다. 와이파이, 3G, LTE, LAN, 블루투스 등 연결할 수 있는 종류가 다양하다. 어떤 걸 쓰든간에 TCP/IP만 쓰면 인터넷은 되니까.

Link Layer의 전송 단위는 Frame이다. 이 프레임이 다른 장비들에서 동시에 전달되면 충돌나서 쓸 수 없게 된다. 이것을 처리하는 역할이 Link Layer.

Broadcast Medium : 게이트웨이 라우터에게만 전달했을 뿐인데 사실 다 들린다. 내가 누구한테 '시간 있어요'라고 물어보면 주변 사람들도 다 들린다. 이러한게 브로드캐스트 미디엄. 이러한 상황에서 여러 사람이 말하면 오디오 겹침. 게이트웨이 라우터 입장에서도 똑같다.

### Ideal multiple Access Protocol

 R bps의 속도를 가진 브로드캐스트 채널에서, 1) 한 사람이 전송하길 원하면, R bps의 속도만큼 전송할 수 있어야 한다. 2) M개의 노드가 전송하길 원하면, R/M bps만큼의 속도만큼 전송할 수 있어야 한다. 3) 중간에 누가 있어서 교통정리 해주는 것이 아니라, 각자 분산적으로 대화할 수 있어야 한다. 중재자 필요없이. 4) 단순한 프로토콜이어야 한다. 이 네 가지 바람이 충족되어야 한다.

### MAC(Medium Access Control) Protocol : Taxonomy

 누가 말을 할 지 컨트롤 하는 프로토콜. 어느 미디엄이 접근할 수 있는지 제어하는 것. 

#### Channel Partitioning

##### TDMA : Time Division Multiple Access

 시간을 나눠서 액세스한다. 시간을 나눠서 이 시간엔 니가 Access해. 1) 장점: 충돌나지 않는다. 2) 단점1 : 노드 개수가 적을 때, 비효율적이다.

##### FDMA : Frequency Division Multiple Access

 주파수를 나눈다. 1) 장점 : 충돌 안생김, 2) 단점 : 노드 개수가 적을 때, 채널 사용이 비효율적이다.

#### Random Access

 채널 파티셔닝 방식의 장단점을 극단적으로 바꿈. 원할 때 자기 하고 싶은 말 하는 것. 동시에 액세스 하면 충돌 생김. Collision 발생 시, 어떻게 recovery 할지. 현실적으로 랜덤 액세스 많이 사용함. 

##### CSMA(Carrier Sense Multiple Access)

내가 전송하고 싶은 프레임이 있을 때, 누군가 이야기 하고 있으면 전송하지 않고, 없으면 이야기 하겠다. 사람이 이야기하는 것과 같음. 옆에서 친구 이야기 하고 있는데 다른 이야기하면 좀 그렇잖아 ;; 

###### CSMA Collision

 전자기파가 퍼지고 있는데 나는 아직 못들음. 그런데 내가 이야기하고 싶다. 그래서 캐리어 센스 해보니까, 아무도 이야기 하지 않고 있는것으로 나옴. 그래서 이야기 했는데, 충돌났다. 전자기파의 진행속도가 빛의 속도라는 물리적 제한이 있다. 이걸 해결할 방법이 없다. 그래서 충돌 발생 시 피해를 최소화하는 방법이 CSMA/CD이다.

![csma collision에 대한 이미지 검색결과](https://www.cs.umd.edu/~shankar/417-F01/Slides/chapter5a-aus/img026.gif)

##### CSMA/CD(Collision Detection)

  둘이 이야기 하는데 말이 겹침. Collision 발생 했다는 걸 탐지하고 일단 둘 다 멈춤.  낭비되는 데이터 양은 더 적음. Detect하는 순간 내 프레임 전송을 멈춘다는 것은 이 프레임이 날라갔다는 말. 재전송 해야 한다. Random time을 돌리고 이 시간 이후에 다시 재전송 시도한다. Random time이 길면 비효율 발생할 것이다. 랜덤의 선택 폭이 좁아야 재전송할 것이다. 하지만 너무 좁으면 또 충돌날 가능성이 있다. 첫 충돌에 대해서는 짧게, 또 충돌나면 곱하기 2, 또 충돌나면 곱하기 2 ... 이렇게 된다.  Binary Expand Buffer. 이더넷이든 와이파이든 많은 호스트가 붙어있으면 우리가 체감하는 딜레이가 크다. 인터넷 속도가 왜 이렇게 느리지 하는 것은 Link Layer의 문제이다. 

 내가 전송하는 전자기파의 Signal Strenth와 다른 사람의 신호 세기는 비슷하다. 케이블로 보호되어 있기 때문에. 나는 말하면서 또 듣고 있다. 내가 말하는 정보와 듣는 정보가 다르면 충돌난 것이다.

#### Taking turns

 channel partitioning과 random access는 극단적으로 다른 장단점을 가지고 있다. channel partitioning은 사용자가 많을 때 유리, random access는 사용자가 적을 떄 유리.

##### 방안 1

 taking turns는 중앙에서 관리하는 것. 사회자. random access의 장점인 원하는 때 보낼 수 있는 것이 있지만, 중앙 관리 시스템이 다운되면 망.

##### 방안 2

 토큰이라는 특별한 데이터로 관리. 토큰이 있으면 보낼 데이터 보낼 수 있다. 토큰이 없으면 못보냄. 토큰 잃어버리면 망.

### Ethernet

 스위치라는 장치를 두고 추가할 호스트가 있으면 꽂는다. IP 패킷이 링크 레이어로 와서 헤더가 쌓이고 Frame이 된다.

![Ethernet header에 대한 이미지 검색결과](https://119904-342459-raikfcquaxqncofqfm.stackpathdns.com/wp-content/uploads/2019/01/ethernet-header.png)

- Preamble은 무시. 
- Destination Addr, Src addr. 이거는 MAC addr이다.
- type은 arp냐 뭐냐. 이런거 알려주는거고. 

CSMA/CD를 사용한다. 구글까지 데이터 보내고 싶다. 링크 레이어는 일단 나의 바로 앞에 있는 게이트웨이까지 패킷을 잘 보내는 것이 목표이다. 어떻게 살아서 게이트웨이까지 갈 수 있을까. 

 내가 프레임을 CSMA/CD를 통해 보냈다. 그런데 피드백을 주지 않으니까 갔는지 아닌지 확신이 없다. 유선상황에서는 최소한 외부로부터 노이즈가 없기 때문에 우리간의 충돌만 없으면 게이트웨이까지 간다. 충돌이 있을 경우, 나는 재전송하면 된다. 그렇다면 CSMA/CD에서 Collision Detection이 가장 중요하게 된다. 만약 충돌났는데 내가 감지하지 못한다면 재전송을 못하니까 망하는 것. 결국 CSMA/CD에서는 100% collision detection이 되어야 한다. 그러면 어느 경우에 Collision Detection을 못하게 될까??

#### 상황

 A가 전송하고 싶어서 Carrier sense 했는데 가능하다고 나옴. 그래서 데이터 보낸다. 그래서 B C D E F까지 간 상태임. G가 데이터 보내고 싶어서 캐리어 센스 해봄. 자신에게 아무것도 도착하지 않았으니까 데이터 보낸다. 보내고 나니까 콜리전 생긴거 알게됨. 멈춘다. 그러면 앞에 말한 것들은 다시 담을 수 없다. 앞에 보낸 것들이 F E D C B까지 가면서 콜리전이 계속 발생하고 있다. A에게 도착하기 전에 A는 모든 데이터를 다 보냈다. 그러면 A 입장에서는 다 보냈다고 생각해서 재전송 하지 않는다. 그러나 데이터는 콜리전 생겼기 때문에 망함. G는 충돌감지 제대로 했지만, A는 하지 못했다.

 A는 왜 충돌감지 못했을까. A의 프레임이 조금만 더 컸으면 충돌방지 할 수 있지 않을까. 분명 Propagation delay가 있는데 이걸 감당할만큼 A 프레임의 사이즈가 크지 않았다. A의 프레임이 너무 짧았다. Lan선의 최대 길이, Propagation delay를 감안해서 프레임 사이즈에 최소값이 정해져있다. 64byte. 내가 보내고자 하는 실제 바이트는 15바이트이면, 뒤에 패딩을 붙인다. 이야기가 끝났지만 뒤에 Padding을 보낸다. 00000... 이런식으로.

 이제 100% detect 하기 때문에 무조건 게이트웨이 라우터로 간다고 할 수 있다. 

 