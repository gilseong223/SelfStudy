# 위메프 직무면접 대비

[TOC]

## Spring MVC와 Spring boot의 차이?

 스프링은 DI(Dependency Injection)을 사용해서 IoC(Inversion of Control)를 이룬다. 이것은 어플리케이션끼리의 결합도를 낮춰주는 역할을 한다.

 그러나 처음에 spring을 사용한 이유는 이러한 특성때문이 아니라 웹 어플리케이션에 특화된 Spring MVC라는 모듈을 이용하기 위해서이다.

 MVC에서 Controller, Service, Component를 사용하면서 각 클래스들을 연결할 때, DI로 사용함으로써 결합도를 낮추게 된다. 

 스프링부트는 초기 설정을 최소화해준다. dependency에 spring boot starter 만 써주면 설정완료.

##DB로 모델링 어떻게 했나요 

 - 우리 팀이 원하는 최종 결과물을 프로토타입으로 만들었다. oven이라는 목업툴을 통해.
- 여기에 사용될 수 있는 테이블이 무엇이 있는지 확인했다. 유저, 음식, 공지사항, q&a 정도가 있더라.
- 이후 erwin으로 erd를 그려보았다. 추천 알고리즘을 구성하기 위해 유저가 섭취한 음식 정보가 필요했다. 유저와 음식이 N:M 비율로 필요했기 때문에 섭취음식이라는 테이블을 따로 구성했다.
- erd를 통해 필요한 테이블을 만들었다.

## 인증은 어떻게 했나요

firebase oauth를 이용했다. oauth는 인증을 하는 방식 중 하나이다. 사용자는 아이디와 비밀번호를 통해 인증 서버에 인증한다. 해당 아이디와 비밀번호가 일치하다면 그 유저의 권한을 인증하는 토큰을 발급한다. 발급받은 토큰으로 유저는 해당하는 권한에 맞는 서비스를 이용할 수 있다. 토큰이 만료되었다면, 토큰을 재발급한다.

## 추천 알고리즘 

### A-priori

 두 item이 한 장바구니에 자주 포함되어 있으면 두 아이템은 유사하다고 판단할 수 있다. 그렇기 때문에 상품 추천으로 유사한 아이템을 추천할 수 있다. 어떤 방식으로 두 아이템을 자주 포함되어 있는지 판단하는지에 대한 알고리즘이다.

 먼저 자주(frequent) 포함되어 있는 것이 무엇인지 알아야 한다. 두 개의 아이템이 항상 함께 있더라도 자주 포함되어 있지 않다면 유사한 아이템인지에 대한 의문이 있을 것이다. 어느 정도의 기준이 있어야 한다. 그 기준을 넘어서면서 두 아이템이 함께 있어야 자주 포함되어 있다고 할 수 있다.

 monotonicity 성질을 이용하면 많은 데이터가 존재해도 효율적으로 처리할 수 있다. 먼저 각 아이템이 frequent한지 확인한다. 둘 중의 한 아이템이라도 frequent하지 않다면 쌍으로는 절대 frequent하다고 할 수 없다.

 하나의 아이템일 때, frequent한 쌍을 기준으로 다시 2차원 배열을 구성해서, 두 개의 아이템일 때 frequent한지 파악한다. 이후 배열에서 쌍으로 frequent한 쌍을 찾는다. 이 기법은 유저와 상관없이 이 아이템을 선택한 모든 사람에게 유사한 쌍의 아이템을 소개한다.

### Hirerachical Clustering

 일단 각 점끼리의 거리를 찾는다. 여기에서 N^2의 시간복잡도가 걸린다. 점까지의 거리를 구하면 최소힙에 Pair를 넣어준다. 이렇게 했을 때, 가장 짧은 페어가 나온다. 그러면 이 페이를 출력하고, 한 클러스터로 묶는다. 이후 이 페어의 Centroid를 구해서 표를 다시 구현하고, 최소힙에서도 이전의 점에 대한 모든 정보를 삭제하고, 새로운 페어와 다른 점에 대한 정보를 넣어준다. 이렇게 사용자가 원하는 개수의 클러스터 집합이 될 때까지 반복한다. 이전의 점에 대한 정보를 최소힙에서 삭제 (nlogn), 배열 새로추가 + 최소힙에 추가(n logn) 이걸 최대 n번 반복하게 되니까 n^2 log n 만큼의 시간복잡도가 걸린다.

### Matrix Factorization

 유저, 영화의 2차원 배열을 상상했을 때, 각 칸에는 한 유저가 한 영화에 대해 몇 점의 평점을 주었는지에 대한 정보가 들어있다. 여기에 feature라는 행렬을 유저길이 만큼 ( N * feature개수), 영화 길이 만큼 ( M * feature개수) 만든다. 각 feauture에는 유저가 이 영화에 대한 평가가 있다. 예를 들어 feature의 간단한 예로는 장르가 있다. 유저가 코미디 장르에 대해 관심이 없고, 액션에 관심이 있다면 이 유저의 feature 배열에 코미디에 대해서는 0, 액션에 대해서 1으로 작성될 것이다. 그리고 이 영화의 특징은 액션의 정도는 5, 코미디에 대해서는 0이다. 이 유저가 이 영화에 대해 5점을 책정했을 때, 해당 feature들이 설정될 것이고, 이 feature를 통해서 유저가 보지 않은 영화에 대해 예상 점수가 나오게 된다.

## Rest API의 장단점?

 http uri를 통해 자원을 명시하고, http method를 통해 해당 자원에 대한 crud를 명시하는 것.

  이전에는 어플을 개발하기 위해서 백엔드에서부터 프론트엔드의 디자인을 생각하면서 만들어야했다. 그러나 rest api는 백엔드, 프론트엔드는 오로지 데이터를 보내거나 받는다. 그렇기 때문에 프론트엔드를 고려하지 않고 기능만 구현하면 된다. 클라이언트가 웹이든 모바일이든 서버에서는 같은 데이터만 보여주면 되는 것이다.

 프론트엔드와 백엔드가 독립적이기 때문에 데이터 명칭만 맞춘다면 프론트엔드 개발자와 백엔드 개발자는 독립적으로 기능을 구현할 수 있다.

 그러나 표준이 없다. 각 어플리케이션, 서비스마다 제각각으로 만들어져 나온다. api 문서를 작성해 어떻게 사용하는지 알려줘야한다.

## 금융이란?

 신용을 바탕으로 투자를 해 새로운 사업을 시작할 수 있도록 돕고, 사업으로 인해 얻은 돈을 돌려받는 것.  

## 사피엔스와 금융

 신대륙 개척할 때 이미 신용을 바탕으로 투자를 했다. 새로운 땅을 개척할 때마다 엄청난 부로 이어졌다. 그러나 실패하는 경우가 더 많았다. 콜럼버스도 여러 나라를 돌다가 스페인에 가서야 투자를 받을 수 있었다. 이후에는 유한책임을 통한 투자로 이어졌다. 여러 사람이 투자를 해서 신대륙 개척을 하고 부를 얻으면 그 부를 나누고, 발견을 하지 못하는 경우에도 그리 큰 타격을 받지는 않는다. 

## 장하준의 경제학강의와 금융

 고전학파와 신고전학파에서 개인의 이기심이 전체의 이득이 된다는 것을 믿었다. 그래서 성장한 줄 알았다. 그러다 점점 시장을 놔두기엔 한계가 있어서 정부가 등장한 줄 알았다. 그러나 그것은 반만 맞았다. 그것보다는 정부가 보호무역을 했기 때문에 성장했다.  그러한 가운데 시장을 두어서 경제가 성장할 수 있었다. 당시에 성장한 국가가 이제는 시장주의를 앞세워 관세를 철폐하려고 한다. 이것은 새롭게 성장하려고 하는 나라에게는 불합리하다. 미국도 성장률이 낮자 보호주의로 돌아서고있다.

 국민총소득, 국내총샌산, 구매력평가 등에 대해 배웠다. 한 나라가 성장했다고 할 때, 40%인지 60%인지 감을 잡을 수 없다. 실제 숫자는 그래서 중요하다. 이를 나타내는 것들이 국민총소득 등이다. 