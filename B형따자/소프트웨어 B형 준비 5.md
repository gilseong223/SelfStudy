# rkskekfkakqktk

[TOC]

## 간담회 참석

### 문제

  삼성의 강의실은 N개의 방으로 이루어져 있고, 각 강의실에는 한 명의 사원이 강의를 듣고 있다.

편의상 각 사원에 1번부터 N번까지 번호를 붙이도록 하자.  하루는 X번 사원의 강의실에서 간담회를 열기로 하였다.

각 사원들은 각자의 강의실에서 X번 사원의 강의실까지 갔다가 간담회를 마치고 돌아오려 한다.

이 때, 이동하는 경로는 최단 경로로 이동한다. 다만 문제는 각 강의실을 잇고 있는 M개의 길이 일방통행이라는 점이다.

결국, 그 강의실까지 가는 경로와 그 강의실에서 돌아오는 경로가 다를 수 밖에 없다.

각 길의 정보가 주어졌을 때, 간담회에 참석했다가 돌아오는데 소요되는 시간이 가장 긴 사원의 소요 시간을 알아내자.


**[입력]**

첫 줄에 테스트케이스의 개수 T가 주어진다. (1 ≤ T ≤ 19)

각 테스트 케이스의 첫 번째 줄에 사원의 수 N, 길의 수 M, 간담회를 여는 강의실에 있는 사원의 번호 X가 주어진다. (1 ≤ N ≤ 50,000, 1 ≤ M ≤ 500,000)

각 테스트 케이스의 두 번째 줄부터 M개의 줄에 걸쳐 각 길의 정보 s, e, t가 주어진다.

s는 일방통행 길이 시작되는 강의실의 번호이고, e는 길이 끝나는 강의실의 번호이다.

t는 그 길을 지나가는데 걸리는 소요 시간이다. 소요 시간은 1 이상 100 이하이다.

**[출력]**

각 테스트케이스마다 한 줄에 걸쳐, 테스트케이스 수 “#(TC) “를 출력하고,

간담회에 참석했다가 돌아오는데 소요되는 시간이 가장 긴 사원의 소요 시간을 출력한다.  



### 솔루션

최단거리라는 말이 나왔을 때 가장 먼저 떠올려야하는 알고리즘 중 하나가 다익스트라이다. 

#### O(N^2)

1번에서 모든 정점까지의 최단거리. 일단 다른 정점 다 INF 해놓고. 시작점은 0.
 1) 아직 확정되어 있지 않은 노드 중에서 가장 작은 노드를 고른다. 2) 정점에서 이어진 간선들을 하나씩 확인한다. 3) 모든 노드가 확정될 때 까지 1,2를 반복한다.

#### Heap

위의 작업에서 1) 최단거리가 확정되지 않은 노드 중, 가장 작은 노드를 고른다. Min Heap으로 구현해서 O(log N) 2) 정점에서 이어진 간선들을 하나씩 확인한다.  O(M log M)

 

## Closest

### 문제

  2차원 좌표계에 있는 N개의 점이 주어진다.

이 점들 중 가장 가까운 두 점의 거리를 구하는 프로그램을 작성하라.

단 거리는 Euclidean Distance(Sqrt((x1-x2)2 + (y1-y2)2))를 이용한다.


**[입력]**

첫 줄에 테스트케이스의 개수 T가 주어진다. (1 ≤ T ≤ 25)

각 테스트 케이스의 첫번째 줄에는 처음 점의 개수를 나타내는 N이 주어진다. (3 ≤ N ≤ 100,000)

다음 N개의 줄에는 각 점의 좌표 x y가 공백으로 구분되어 주어진다. (-100,000 ≤ x, y ≤ 100,000)

**[출력]**

각 테스트케이스마다 한 줄에 걸쳐, 테스트케이스 수 “#(TC) “를 출력하고, 가장 가까운 두 점의 거리의 제곱을 출력한다.

### 솔루션

#### 분할정복

절반씩 나눠서 한쪽 찾고, 다른 쪽 찾고.  이 문제에서 어떻게 자를 것이냐. x축으로만 정렬한다.  왼쪽과 오른쪽을 개수가 비슷하게 잘 나눠야 함. 

왼쪽 내부에서만 두 점이 있거나, 오른쪽에서만 두 점이 있거나, 왼쪽에 한 점, 오른쪽에 한 점이 있는 경우겠지. 왼쪽 내부에서만 한 것은 재귀호출로 하고, 오른쪽 내부에서만 한 것도 재귀호출로. 이제 걸친 애를 찾아봐야 함.

d = min(DL, DR);

x축에서 d 이상 떨어진 애들은 비교할 가치가 없다. 