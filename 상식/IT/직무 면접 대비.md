# 직무 면접 대비

[TOC]

## 전공 질문

### Q. 자바 실행과정이 어떻게 되죠?

 ![자바 메모리 구조](https://t1.daumcdn.net/cfile/tistory/2540294C5654207F26)

 실행될 클래스 파일을 메모리에 로드 후 초기화 작업을 수행한다. 메소드와 클래스 변수들을 해당 메모리 영역에 배치한다. 클래스 로드가 끝난 후 JVM은 main 메소드를 찾아 지역변수, 객체변수, 참조변수를 스택에 쌓는다. 다음 라인을 진행하면서 상황에 맞는 작업을 수행한다.

- Class Loader : JVM 내로 클래스를 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈로, 런타임시 동적으로 클래스를 로드한다.
- Execution Engine : Class Loader를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트 코드를 실행한다. 이 때 Execution Engine은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
- Garbage Collector : JVM은 Garbage Collector를 통해 메모리 관리 기능을 자동으로 수행한다. 애플리케이션이 생선한 객체의 생존 여부를 판단하여 더 이상 사용되지 않는 객체를 해제하는 방식으로 메모리를 자동 관리한다.
- Runtime Data Area : JVM이 운영체제 위에서 실행하면서 할당받는 메모리 영역이다. Class Loader에서 준비한 데이터들을 보관하는 저장소이다.

### Q. JVM은 메모리를 어떻게 사용하죠?

 ![Runtime Data Areas & Heap Area](https://t1.daumcdn.net/cfile/tistory/216AE04C5654207F0A)

- Method (Static) Area : JVM이 읽어들인 클래스와 인터페이스에 대한 런타임 상수 풀, 멤버 변수(필드), 클래스 변수(Static 변수), 생성자와 메소드를 저장하는 공간이다.
- Runtime Constant Poll 
  - 클래스 파일 constant_pool 테이블에 해당하는 영역이다.
  - 클래스와 인터페이스 상수, 메소드와 필드에 대한 모든 레퍼런스를 저장한다.
  - JVM은 런타임 상수 풀을 통해 해당 메소드나 필드의 실제 메모리 상 주소를 찾아 참조한다.
- Method area / Runtime constant pool의 사용기간 및 스레드 공유 범위
  - JVM 시작시 생성된다.
  - 프로그램 종료 시, 명시적으로  null 선언 시 종료된다.
  - 모든 스레드에서 공유한다.
- Heap Area
  - New 연산자로 생성된 객체 또는 객체(인스턴스)와 배열을 저장한다.
  - 힙 영역에 생성된 객체와 배열은 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
  - 참조하는 변수나 필드가 없다면 의미 없는 객체가 되어 GC의 대상이 된다.
  - 힙 영역의 사용기간 및 스레드 공유 범위
    - 객체가 더 이상 사용되지 않거나 명시적으로 null 선언 시 GC 대상이 된다.
    - 모든 스레드에서 공유한다.
- Stack Area
  - 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.
  - 메소드를 호출할 때마다 프레임을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행한다.
  - LIFO 구조로 push와 pop기능 사용
  - 메소드 정보, 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
- PC Register
  - 현재 수행 중인 JVM 명령 주소를 갖는다.
- Native Method Stack Area
  - 자바 외 언어로 작성된 네이티브 코드를 위한 스택이다.
  - JNL(Java Native Interfaece)를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 스택이다.
  - 네이티브 메소드의 매개변수, 제역변수 등을 코드로 저장한다.

### Q. Heap Area란 무엇인가요?

- Young Generation : 이 영역은 자바 객체가 생성되자마자 저장되고, 생긴지 얼마 안되는 개체가 저장되는 곳이다. 시간이 지나 우선순위가 낮아지면 Old 영역으로 옮겨진다. 이 영역에서 객체가 사라질 때 Minor GC가 발생한다.
- Old Generation : Young Generation 영역에서 저장되었던 객체 중에서 오래된 객체가 이동되어 저장되는 영역이다. 이 영역에서 객체가 사라질 때 Major GC가 발생한다.
- [힙과 스택 잘 설명해놓은곳](https://wanzargen.tistory.com/17) 

### Q. 직렬화, 역직렬화란?

 직렬화란 데이터를 문자열 형태로 변화하는 방법이다. 자바 직렬화, 문자열 형태의 직렬화 등이 있다. 문자열 형태의 직렬화는 JSON, CSV 등의 방법이 있다.

![No Image](https://nesoy.github.io/assets/posts/20180418/1.png)

 자바 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술(직렬화)과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러 이야기 한다.

 자바 기본 타입과 java.io.Serializable 인터페이스를 상속받은 객체는 직렬화 할 수 있는 기본 조건을 가진다. 

``` java
public class Member implements Serializable {
    private String name;
    private String email;
    private int age;

    public Member(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
    @Override
    public String toString() {
        return String.format("Member{name='%s', email='%s', age='%s'}", name, email, age);
    }
}
```

ObjectOutputStream을 사용하여 직렬화를 진행한다.

``` java
public static void main(String[] args){
    Member member = new Member("김배민", "deliverykim@baemin.com", 25);
    byte[] serializedMember;
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {
            oos.writeObject(member);
            // serializedMember -> 직렬화된 member 객체
            serializedMember = baos.toByteArray();
        }
    }
    // 바이트 배열로 생성된 직렬화 데이터를 base64로 변환
    System.out.println(Base64.getEncoder().encodeToString(serializedMember));
}
```

 역직렬화는 직렬화된 자바 객체를 자바 형태로 다시 만드는 것이다. 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하고, import 되어 있어야 한다. 직렬화와 역직렬화를 진행하는 시스템이 서로 다를 수 있다는 것을 고려하고 코드를 짜야 한다. 자바 직렬화 대상 객체는 동일한 `serialVersionUID`를 가지고 있어야 한다.

장점

- 자바 시스템에 최적화되어 있다. 복잡한 데이터 구조를 가진 클래스의 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 직렬화 가능하다.
- 역직렬화가 되면 기존 객체처럼 바로 사용할 수 있게 된다. 개발자 입장에서 상당히 편하다.

단점

- 클래스구조가 변경된 경우, 역직렬화시 에러가 발생할 수 있다.
- serialVersionUID가 동일한 경우,
  - 이름은 그대로인데 type이 변경되었을 경우 에러
  - 추가되는 경우는 에러발생 X
  - 필드를 지우는 경우 문제를 일으킬 수 있음.

### Q. 클라이언트 측의 저장소는 무엇이 있는가?

쿠키, 인덱스DB, 로컬 스토리지

[https://dongwoo.blog/2016/12/19/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%B8%A1%EC%9D%98-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/](https://dongwoo.blog/2016/12/19/클라이언트-측의-저장소-살펴보기/)



### Q. Process에서 Stack, Heap이 어떻게 동작하냐

#### QQ. 스택이 꼭 필요하다고 생각하나. 스택없이 힙으로만 동작한다면 어떻게 동작하는지 그 과정을 설명하라

  스택없이 동작하는 것을 구현하기 위해 지금 시스템에서 스택을 쓰지 않는 방법을 생각해보자. 스택을 쓰지 않기 위해서는 매개변수, 지역변수를 사용하지 않으면 된다. 메소드에서 사용할 모든 변수를 힙에 저장해두어야 하기 때문에 메소드를 사용하지 않을 때도 힙 안에 모든 정보가 저장되어 있다. 스택이 있으면 데이터가 유동적으로 삭제되었다가 다른 메소드를 통해 생성이 되지만, 힙에 데이터를 저장해두면 객체가 없어지지 않는 이상 변수는 사라지지 않는다. 그렇기 때문에 공간 효율성이 떨어지게 된다.

### Q. 자바에서 상속을 써본 적 있는지.

 

## NHN

### Feel the toast

 민피셜 - 오전에 네트워크 DNS 비슷한거 봤다고 함. IP주소와 Name으로 구성된 테이블 구성했다고 함. 오후에 이걸 토대로 1:1 코드 리뷰하고, 직무 면접 봄.

## 자기소개서 1

### 알고리즘

  저는 알고리즘 조별과제에서 유연한 사고로 알고리즘을 구성해 조별 토너먼트를 우승했습니다.  세 팔이 있는 저울로 불량 동전을 찾는 알고리즘을 개발하는 것이 과제의 내용이었습니다. 그리고 가장 적은 시도로 불량 동전을 찾는 조가 우승하는 방식으로 점수를 주는 것이었습니다. 가장 먼저 생각나는 방식은 하나하나 모두 세어보는 방식이었습니다. 역시나 그리 좋은 방법은 아니어서 꽤나 많은 시도 끝에 불량 동전을 찾아냈습니다. 이 방법은 누구나 생각할만하다고 생각했기 때문에 다른 알고리즘을 고안해보자고 조원들과 결정내렸습니다. 그 후 생각해낸 방법은 확률을 생각해보는 것이었습니다. 불량 동전을 세다가 중간에 더 세지 않고 결과를 확인했을 때, 언제 확인하는 것이 정답일 확률이 높은지 계산 해봤습니다. 불량 동전은 30~35%의 확률로 섞여 있었습니다. 이를 고려하여 적절한 시기를 찾았고, 제출한 것이 불량 동전이 아닐 경우는 1번의 비용이 발생하는 패널티밖에 없었기 때문에 다시 세어보면 되는 일이었습니다. 이러한 방식으로 알고리즘을 만들어 토너먼트에서 1등을 했습니다. 조원들끼리 머리를 맞대어 생각해낸 알고리즘이 좋은 결과를 내서 프로그래밍에 대한 자신감이 생겼던 경험이었습니다. 이러한 자신감으로 빅데이터 프로젝트, 웹 프로젝트 등에 발을 들여 전공 분야의 다양한 이론 및 실습 경험을 쌓을 수 있게 되었습니다.

Q. 이 프로젝트에서 가장 힘들었던 점은?
A. 당시 실력은 다른 사람의 코드를 읽을 수는 있는데 내가 처음부터 직접 코드를 짜지는 못했다. 알고리즘에 대한 연습이 되어 있지 않은 상태였다. 각자의 코드를 짜야 하는 상황이었는데, 나의 실력을 조원들에게 들키기 싫어 코드를 짜지는 않고 안절부절 했다. 그러다 한 조원이 완전탐색으로 코드를 만들어 놓았는데, 이 코드를 변형해서 확률을 만들었다. 결론적으로 조원들이 좋아했지만 개인적으로는 자괴감이 컸다.

Q. 지금은 본인의 알고리즘 실력이 어느 정도라고 생각하나?
A. 객관적인 실력은 삼성역량테스트 A+이다. 이전보다 알고리즘의 종류에 대해서는 더 잘 알고 있는데, 시뮬레이션 문제에서 실력이 준 것 같다. 하반기 취업 준비를 전공 지식, 인적성 중심으로 하면서 알고리즘을 잠시 쉬었더니 실력이 급격하게 줄었다. 효율성을 고려해서 알고리즘을 잘 만드는데 예외 케이스에 대해 그리 잘 하는 편이 아니다.

### 웹정보시스템

 방대한 정보를 이용하여 어떻게 원하는 정보를 얻는지 배웠던 수업입니다. 빅데이터와 관련이 있어 처음부터 흥미롭게 들었던 수업입니다. 그러나 생각보다 이해가 쉽지 않아 고전했습니다. 어려웠던 만큼 이를 극복하고자 하는 마음이 커서 수업이 끝나고 항상 도서관에서 복습을 했습니다. 그렇게 기초를 차근차근 쌓아나간 결과 응용부분의 이해가 훨씬 용이했습니다. 상품추천 시스템, 비슷한 집단 찾기 등 빅데이터 분석의 기초를 쌓아 나갔고 자신감이 생기자 이 분야의 심화학습을 하고 싶어졌습니다. 그래서  100만 개의 영화 평점 데이터로 영화 추천 서비스를 만드는 프로젝트를 했습니다.

### 자신있는 프로그래밍 언어

[JAVA] 

자바와 스프링 프레임워크로 식품 정보를 제공하며 안전한 식품 여부를 알려주는 프로젝트를 했습니다.

 A-priori 알고리즘을 이용해 추천 기능을 구성했습니다. 나의 음식 습관과 가장 비슷한 사람을 찾고 그 중에서 내가 먹지못한 음식이 있다면 추천받는 서비스입니다. 식단 짜기 기능은 유저가 섭취할 총 칼로리와 원하는 음식을 선택하면 남은 칼로리의 음식 중에 유저에게 추천할 음식으로 식단을 짜주는 기능입니다. 이러한 기능으로 사용자에게 새로운 경험을 제공하고자 했습니다. 프로젝트에서 가장 중요하게 생각했던 것은 협업이었습니다. 2인 프로젝트였는데 2명이 협업을 한다고 해도 새로운 기능이 추가되면 다른 팀원은 당연히 프로세스를 모를 수 밖에 없습니다. 저는 추가 기능 구현이 끝나면 문서를 작성해 서로가 알아보기 쉽게 하자는 의견을 냈습니다. 다른 팀원이 동의해 각자 문서를 작성했고, 저는 로그인 서비스 이외에도 푸시 알림 문서, 배포 문서 등을 작성해 팀원에게 공유했습니다. 이후 기능과 기능끼리 결합하여 효율적인 코드 사용이 가능해졌습니다. 이를 통해 효율적인 협업을 위해서는 서로 아는 것을 공유해야 한다는 것을 알 수 있었습니다. 또한 문서로 남겼기 때문에 다른 프로젝트에서 기능을 구현할 때 이를 활용해 재사용성을 높일 수 있었습니다.



### 미래 모습

[어플을 떠나지 못하게 하는 개발자] 

저는 NHN에서 일상 금융 플랫폼을 구축하고 싶습니다. 가계부를 기반으로 페이코, KCP 등 다른 서비스의 사용성도 함께 높이는 어플을 만들고자 합니다.

 단지 얼마 썼는지 알려주는 것뿐만 아니라 한눈에 보기 편한 UI와 은행 연동, 금융 진단까지 제공하는 플랫폼으로 고객이 일상 속에서 당연하게 NHN의 가계부를 떠올리는 서비스를 제공하고 싶습니다.

 일상 금융 플랫폼을 구축하고 싶다는 생각을 한 것은 페이코 때문입니다. 페이코는 간편한 웹 상 결제 및 지갑을 들고 다닐 필요 없다는 이유만으로 이미 많은 고객의 일상을 바꾸었습니다. 이외에도 다양한 금융 어플을 구축했기 때문에 이를 통합할 수 있는 것이 필요하다고 생각했고 이를 위해서는 NHN에서 가장 잘 할 수 있다고 생각했습니다. 또한 다양한 IT 서비스를 만드는 NHN의 특성이 저의 생각을 잘 실현해줄 것으로 판단했습니다.

 저는 NHN에서 새로운 미래를 창조하며 고객에게 새로운 경험을 안기고 싶습니다. 단기적으로는 페이코, KCP 등 기존에 있는 기능을 활용할 방법을 찾기 위해 이들을 학습하는 시간을 가지겠습니다. 또한 해외의 창의적인 어플은 무엇이 있는지 비즈니스 사례를 조사해 보겠습니다.

 장기적으로는 NHN만의 특별한 기능, 플랫폼 등을 구축하여 고객이 NHN의 서비스를 꾸준히 쓰도록 유인을 제공하는 개발자가 되고 싶습니다.