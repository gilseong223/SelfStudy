# 직무 면접 대비

[TOC]

## 전공 질문

### Q. 자바 실행과정이 어떻게 되죠?

 ![자바 메모리 구조](https://t1.daumcdn.net/cfile/tistory/2540294C5654207F26)

 실행될 클래스 파일을 메모리에 로드 후 초기화 작업을 수행한다. 메소드와 클래스 변수들을 해당 메모리 영역에 배치한다. 클래스 로드가 끝난 후 JVM은 main 메소드를 찾아 지역변수, 객체변수, 참조변수를 스택에 쌓는다. 다음 라인을 진행하면서 상황에 맞는 작업을 수행한다.

- Class Loader : JVM 내로 클래스를 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈로, 런타임시 동적으로 클래스를 로드한다.
- Execution Engine : Class Loader를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트 코드를 실행한다. 이 때 Execution Engine은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
- Garbage Collector : JVM은 Garbage Collector를 통해 메모리 관리 기능을 자동으로 수행한다. 애플리케이션이 생선한 객체의 생존 여부를 판단하여 더 이상 사용되지 않는 객체를 해제하는 방식으로 메모리를 자동 관리한다.
- Runtime Data Area : JVM이 운영체제 위에서 실행하면서 할당받는 메모리 영역이다. Class Loader에서 준비한 데이터들을 보관하는 저장소이다.

### Q. JVM은 메모리를 어떻게 사용하죠?

 ![Runtime Data Areas & Heap Area](https://t1.daumcdn.net/cfile/tistory/216AE04C5654207F0A)

- Method (Static) Area : JVM이 읽어들인 클래스와 인터페이스에 대한 런타임 상수 풀, 멤버 변수(필드), 클래스 변수(Static 변수), 생성자와 메소드를 저장하는 공간이다.
- Runtime Constant Poll 
  - 클래스 파일 constant_pool 테이블에 해당하는 영역이다.
  - 클래스와 인터페이스 상수, 메소드와 필드에 대한 모든 레퍼런스를 저장한다.
  - JVM은 런타임 상수 풀을 통해 해당 메소드나 필드의 실제 메모리 상 주소를 찾아 참조한다.
- Method area / Runtime constant pool의 사용기간 및 스레드 공유 범위
  - JVM 시작시 생성된다.
  - 프로그램 종료 시, 명시적으로  null 선언 시 종료된다.
  - 모든 스레드에서 공유한다.
- Heap Area
  - New 연산자로 생성된 객체 또는 객체(인스턴스)와 배열을 저장한다.
  - 힙 영역에 생성된 객체와 배열은 스택 영역의 변수나 다른 객체의 필드에서 참조한다.
  - 참조하는 변수나 필드가 없다면 의미 없는 객체가 되어 GC의 대상이 된다.
  - 힙 영역의 사용기간 및 스레드 공유 범위
    - 객체가 더 이상 사용되지 않거나 명시적으로 null 선언 시 GC 대상이 된다.
    - 모든 스레드에서 공유한다.
- Stack Area
  - 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다.
  - 메소드를 호출할 때마다 프레임을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행한다.
  - LIFO 구조로 push와 pop기능 사용
  - 메소드 정보, 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
- PC Register
  - 현재 수행 중인 JVM 명령 주소를 갖는다.
- Native Method Stack Area
  - 자바 외 언어로 작성된 네이티브 코드를 위한 스택이다.
  - JNL(Java Native Interfaece)를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 스택이다.
  - 네이티브 메소드의 매개변수, 제역변수 등을 코드로 저장한다.

### Q. Heap Area란 무엇인가요?

- Young Generation : 이 영역은 자바 객체가 생성되자마자 저장되고, 생긴지 얼마 안되는 개체가 저장되는 곳이다. 시간이 지나 우선순위가 낮아지면 Old 영역으로 옮겨진다. 이 영역에서 객체가 사라질 때 Minor GC가 발생한다.
- Old Generation : Young Generation 영역에서 저장되었던 객체 중에서 오래된 객체가 이동되어 저장되는 영역이다. 이 영역에서 객체가 사라질 때 Major GC가 발생한다.

### Q. 직렬화, 역직렬화란?



## NHN

### Feel the toast

 민피셜 - 오전에 네트워크 DNS 비슷한거 봤다고 함. IP주소와 Name으로 구성된 테이블 구성했다고 함. 오후에 이걸 토대로 1:1 코드 리뷰하고, 직무 면접 봄.

## 자기소개서 1

### 알고리즘

  저는 알고리즘 조별과제에서 유연한 사고로 알고리즘을 구성해 조별 토너먼트를 우승했습니다.  세 팔이 있는 저울로 불량 동전을 찾는 알고리즘을 개발하는 것이 과제의 내용이었습니다. 그리고 가장 적은 시도로 불량 동전을 찾는 조가 우승하는 방식으로 점수를 주는 것이었습니다. 가장 먼저 생각나는 방식은 하나하나 모두 세어보는 방식이었습니다. 역시나 그리 좋은 방법은 아니어서 꽤나 많은 시도 끝에 불량 동전을 찾아냈습니다. 이 방법은 누구나 생각할만하다고 생각했기 때문에 다른 알고리즘을 고안해보자고 조원들과 결정내렸습니다. 그 후 생각해낸 방법은 확률을 생각해보는 것이었습니다. 불량 동전을 세다가 중간에 더 세지 않고 결과를 확인했을 때, 언제 확인하는 것이 정답일 확률이 높은지 계산 해봤습니다. 불량 동전은 30~35%의 확률로 섞여 있었습니다. 이를 고려하여 적절한 시기를 찾았고, 제출한 것이 불량 동전이 아닐 경우는 1번의 비용이 발생하는 패널티밖에 없었기 때문에 다시 세어보면 되는 일이었습니다. 이러한 방식으로 알고리즘을 만들어 토너먼트에서 1등을 했습니다. 조원들끼리 머리를 맞대어 생각해낸 알고리즘이 좋은 결과를 내서 프로그래밍에 대한 자신감이 생겼던 경험이었습니다. 이러한 자신감으로 빅데이터 프로젝트, 웹 프로젝트 등에 발을 들여 전공 분야의 다양한 이론 및 실습 경험을 쌓을 수 있게 되었습니다.

Q. 이 프로젝트에서 가장 힘들었던 점은?
A. 당시 실력은 다른 사람의 코드를 읽을 수는 있는데 내가 처음부터 직접 코드를 짜지는 못했다. 알고리즘에 대한 연습이 되어 있지 않은 상태였다. 각자의 코드를 짜야 하는 상황이었는데, 나의 실력을 조원들에게 들키기 싫어 코드를 짜지는 않고 안절부절 했다. 그러다 한 조원이 완전탐색으로 코드를 만들어 놓았는데, 이 코드를 변형해서 확률을 만들었다. 결론적으로 조원들이 좋아했지만 개인적으로는 자괴감이 컸다.

Q. 지금은 본인의 알고리즘 실력이 어느 정도라고 생각하나?
A. 객관적인 실력은 삼성역량테스트 A+이다. 이전보다 알고리즘의 종류에 대해서는 더 잘 알고 있는데, 시뮬레이션 문제에서 실력이 준 것 같다. 하반기 취업 준비를 전공 지식, 인적성 중심으로 하면서 알고리즘을 잠시 쉬었더니 실력이 급격하게 줄었다. 효율성을 고려해서 알고리즘을 잘 만드는데 예외 케이스에 대해 그리 잘 하는 편이 아니다.

### 웹정보시스템

 방대한 정보를 이용하여 어떻게 원하는 정보를 얻는지 배웠던 수업입니다. 빅데이터와 관련이 있어 처음부터 흥미롭게 들었던 수업입니다. 그러나 생각보다 이해가 쉽지 않아 고전했습니다. 어려웠던 만큼 이를 극복하고자 하는 마음이 커서 수업이 끝나고 항상 도서관에서 복습을 했습니다. 그렇게 기초를 차근차근 쌓아나간 결과 응용부분의 이해가 훨씬 용이했습니다. 상품추천 시스템, 비슷한 집단 찾기 등 빅데이터 분석의 기초를 쌓아 나갔고 자신감이 생기자 이 분야의 심화학습을 하고 싶어졌습니다. 그래서  100만 개의 영화 평점 데이터로 영화 추천 서비스를 만드는 프로젝트를 했습니다.