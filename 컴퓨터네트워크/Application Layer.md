# Application Layer

[TOC]

## Previous(HTTP)

 http는 상태저장을 하지 않는 프로토콜. 웹 브라우징할 때 상태 기억할 일이 있으면 쿠키를 가지고 관리한다. 아마존에서 사용자를 인식하고, 알맞은 아이템 추천하는 것 이야기하면서 쿠키 이야기 했다.

 웹 프록시는 http 공식 스탠다드에 포함되지 않는다. 사람들이 웹 브라우저 사용할 때 빠른속도로 하기 위해서. 클라이언트가 서버한테 직접 액세스 하지 않고 프록시 서버에 먼저 요청하고, 프록시 서버에 요청한 서버가 있는지 확인하고 있으면 서버에 액세스 한다. 외부에 나가지 않고도 리스폰스를 만들 수 있다. 빠르니까 클라이언트에게 좋고, 서버도 부하가 덜 들어서 좋다.

### Caching

 학교 네트워크. 교내의 데스크탑을 사용하는데, 인터넷으로 나가기 위해서는 교내 게이트웨이 라우터를 통해야 한다. 초당 15개의 http request 있고, request의 평균 크기는 1M bits이다. 갔다가 돌아오는 시간(round trip)이 2초 걸린다(Internet delay). 내부 bandwidth는 100M bps. Access Link의 bandwidth는 15Mbps이면 

 한 번 앞에서 막히면 다른게 다 막힌다. bandwidth 크기에 평균 사용량이 접근하면 접근할수록 한없이 느려진다. 고속도로가 막히는 것과 같은 원리. bottle neck.

 total delay = Internet delay + access delay + LAN delay

 이런 경우에 웹 캐시 사용하면 된다.  캐시 사용해서 캐시에 있는 정보는 가져오면 되고, 아닌 경우는 인터넷으로 나갔다가 가져오면 된다. hit rate이 꽤 높기 때문에 병목현상 덜 생긴다.

### Conditional GET

 HTTP request Get 할 때, 필드 중의 하나로 modify 필드를 하나 만든다. 여기엔 날짜 정보가 있다. 이 날짜 이후에 업데이트 되지 않았으면 오브젝트를 보내지 않고 304 not defined 보낸다. 

 프록시 서버에 4GB짜리 오브젝트가 있다. 클라이언트가 요청했는데, 이게 최신버전인지 아닌지 알 수 없다. Conditional get이 있으면 업데이트가 없으면 '야 니가 최신버전이야'라고 알려주는 것. 그래서 4GB씩 보낼 필요가 없다.

## Application Layer

 서버 프로세스에 접근하기 위해선 주소를 알아야 한다. IP와 Port번호. port번호는 유명한 서비스마다 고정된 번호를 사용한다. http는 80번. 그래서 이건 우선 문제가 없는데, 서버의 IP주소를 알아야 접근하고자 하는 서비스가 동작하는 머신으로 갈 것이다. IP주소는 32bit으로 된 주소체계이다.

### DNS

 IP 외우기 힘드니까 영문을 사용하자. 전화번호부 처럼. 서버이름 있고, 네트워크 주소있는거. 초창기는 이랬다. 서버의 개수가 얼마 안됐기 때문에. 사용자가 많다면 DNS 가지고 있는 서버에 접근해서 여러 개 찾아야 한다. 오래 걸림. DNS 서버가 꺼지면 웹 브라우저 사용 못한다.

 분산시스템으로 구조화 됨. 루트 서버가 전세계 13개 존재함. 그 밑에 도메인 

![1569226948454](C:\Users\multicampus\AppData\Roaming\Typora\typora-user-images\1569226948454.png)

#### DNS records  

| NAME      | value           | type            | ttl  |
| --------- | --------------- | --------------- | ---- |
| ac.kr     | AAA.ac.kr       | NS              |      |
| AAA.ac.kr | ooo.ooo.ooo.ooo | A               |      |
| .com      | xxx.com         | NS(Name Server) | 24   |
| xxx.com   | 111.111.111.111 | A(Address)      |      |

도메인은 호스트를 묶는 군집단이다.  .com 이라는 도메인은 xxx.com이라는 호스트를 관리하는데, 이거는 IP주소 매핑은 아니다. Type은 value가 server인가 address인가 알려주는거. 

 위 테이블에서 ac.kr으로 들어가면 AAA.ac.kr에 들어가서 그 아래의 테이블을 이용한다.

| NAME              | VALUE           | TYPE | TTL  |
| ----------------- | --------------- | ---- | ---- |
| www.uos.ac.kr     | 127.12.12.12    | A    |      |
| library.uos.ac.kr | 222.222.222.222 | A    |      |
| portal.uos.ac.kr  | 123.123.123.123 | A    |      |

쭉 파고 들어가서 마지막에 A 레코드 받고 끝나는 거. 이렇게 분산화해서 네이밍을 관리하니까 업데이트가 편리하다. 도메인 네임을 바꾸면 가장 아래의 Name만 바꾸면 다 찾아간다.

바나나라는 스타트업을 만들고, dns.banana.com이라는 도메인을 얻었다. 그러면 이 도메인에는 테이블이 들어있을 것이다. 여기의 타입들은 다 A일 것이다. 그리고 현재의 테이블을 연결해야 하니까 .com의 테이블에도 레코드 두 개를 만들어야 한다. NS 타입의 네임에는 banana.com이 있을 것이고, A타입의 네임에는 dns.bananas.com이 있을 것이다.

### What is Socket

 소켓이라는 인터페이스를 알아야 우체통에 편지를 넣을 수 있다. 소켓은 사용자 프로세스와 운영체제 안에 있는 Transport layer(우리는 TCP)와의 인터페이스이다. 

### Two Essential types of sockets

#### TCP 기반의 통신

 서버가 켜져 있어야 일단 통신할 수 있다. 서버가 통신을 하는 방법(tcp, udp)를 설정해서 소켓을 생성해야 한다. 이후 특정 포트에 소켓을 넣는 작업. 그리고 이 소켓을 듣는 용도(listen)로 쓰겠다. 호출이 될 때 까지 기다리다가 호출이 오면 accept 가 받아서 처리한다. 

 클라이언트는 소켓을 켜고 connect한다. three-way handshaking이 있고나면 연결 된 것. 이후엔 write read를 반복한다. 연결이 끝나면 close()를 통해 연결이 끊긴다. 

#### UDP 기반의 통신

 이 있는 것 같은데 안 알려줌 ;;



