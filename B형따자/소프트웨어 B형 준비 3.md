# 소프트웨어 B형 준비 3

[TOC]

## 단어가 등장하는 횟수

### 문제

  독서광 동철이는 책을 정말 꼼꼼히 읽는다. 그 증거로, 책에서 어떤 단어가 몇 번 등장하는지 물어보면 정확하게 그 답을 맞춰내는 신기한 능력이 있다.

그런데, 특출난 능력이 있으면 누군가는 시샘을 하게 마련이다.

동철이의 친구 영수는 동철이의 이런 능력을 의심하고 있었지만, 도저히 그 답이 맞는지 세어볼 수가 없어 당신에게 도움을 요청하였다.

영수의 궁금증을 해소해주기 위하여, 책의 내용 B가 주어질 때 특정 단어 S가 등장하는 횟수를 알아내어라.

책의 내용에서 특정 단어가 등장하는 부분이 중첩될 수도 있음에 유의하여라.

예를 들어, B="ABABA"이고 S="ABA"이면 2번 등장하는 것으로 간주한다.


**[입력]**

첫 줄에 테스트케이스의 개수 T가 주어진다. (1 ≤ T ≤ 20)

각 테스트 케이스의 첫 번째 줄에 책의 내용 B가 주어진다.

책의 내용은 알파벳 소문자와 대문자, 그리고 숫자로만 이루어지고, 길이는 1 이상 500,000 이하이다.

각 테스트 케이스의 두 번째 줄에 찾고자 하는 단어 S가 주어진다.

찾고자 하는 단어는 알파벳 소문자와 대문자, 그리고 숫자로만 이루어지고, 길이는 1 이상 100,000 이하이다.

**[출력]**

각 테스트케이스마다 한 줄에 걸쳐, 테스트케이스 수 “#(TC) “를 출력하고, 단어가 등장하는 횟수를 출력한다.  

### 솔루션

문자열 비교를 해시 함수로 많이 한다.  현업에선 충돌을 해결하겠지만, 여기선 다를 확률을 높여서 결과물이 같으면 무조건 문자열이 같다고 생각할 수 있도록.  최대한 확률을 낮추기 위해 `상수값을 세트`로 가져가면서, 해시값이 같으면 무조건 문자열이 같다고 생각할 수 있도록. 

 문자열에 해시를 쓰겠다면 다음과 같은 형식을 쓸 수 있다.  

- 문자열의 각 아스키코드를 d진법으로 해서, m으로 나눈 나머지를 해시값으로 쓴다. 

#### Sliding Window

하나씩 차근차근 가져간다. 이것의 장점은 

A B C D E F G H I J K L

f(ABCDE) = A*d^4 + B*d^3 +  C*d^2 + 

맨 첫 자리를 비교할때는 O(N)이겠지만, 그 다음부터는 O(1)이기때문에 ㄱㅊ...

#### d와 m에 대하여

m : 10^9 + 7 이나 10^9 +? 은 충분히 크지 못하다. 오버플로우되면 자동으로 모드 연산 하도록 되어있기 때문에 m은 보통 2^64으로 만든다. 

d : d의 값은 알파벳 수보다 크면 좋다. 257 정도면 충분하다.  그래도 충돌하면 259 정도면 충분하다. 

해시값이 같을 때 검증하기 위해 문자열을 비교해보겠다고 하면, 해시를 쓰는 이유가 없어진다.

## 두 번 이상 등장하는 문자열

### 문제

  문자열 S가 주어질 때, 이 문자열에서 두 번 이상 등장하면서 가장 긴 부분 문자열을 찾아내시오.

이 때, 부분 문자열이 중첩될 수 있음에 유의하라.

예를 들어, S="ababa"인 경우 가장 긴 부분 문자열은 "aba"가 된다.


**[입력]**

첫 줄에 테스트케이스의 개수 T가 주어진다. (1 ≤ T ≤ 10)

각 테스트 케이스의 첫 번째 줄에 문자열 S의 길이 L이 주어진다. (1 ≤ L ≤ 200,000)

각 테스트 케이스의 두 번째 줄에 문자열 S가 주어진다. 문자열 S는 알파벳 소문자로만 구성되어 있다.

**[출력]**

각 테스트케이스마다 한 줄에 걸쳐, 테스트케이스 수 “#(TC) “를 출력하고, 두 번 이상 등장하면서 가장 긴 부분 문자열의 길이를 출력한다.

만약, 그러한 문자열이 없다면 0을 출력한다.  

### 솔루션

Counting sort, suffix, ~

#### Counting sort

정렬은 두 요소 사이의 관계를 만들어서 하는 것이다. 그러나 이것은 두 수로 비교하는 것이 아니라, 정수의 특징을 사용하는 것이다.

개수 세기 -> 누적합 구하기 -> 역순으로 자리 선정

##### 개수세기

1은 몇 개, 2는 몇 개. 이런식으로 배열 구성

##### 누적합 구하기

##### 역순으로 자리 선정

역순으로 자리 지정 해줬기 때문에 stable 함. 같은 값일 경우 원래 배열에서 가지고 있던 순서 그대로 정렬할 수 있다.

##### 단점

정수가 너무 크면 gg. 실수가 나오면 gg.

#### suffix array

BANANA 있으면

BANANA

ANANA

NANA

ANA

NA

A

이렇게 해놓음.

#### Longest Common Prefix

 Suffix Array를 구했다. 여기에서 최장 공통 접두사. 이웃하지 않은 두 접미사간의 